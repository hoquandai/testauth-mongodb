{"ast":null,"code":"import * as EJSON from \"mongodb-stitch-extjson\";\nimport { wrapDecodingError } from \"../../internal/common/StitchErrorUtils\";\nimport Headers from \"../../internal/net/Headers\";\nimport Method from \"../../internal/net/Method\";\nimport Stream from \"../../internal/net/Stream\";\nimport { StitchAuthDocRequest } from \"../../internal/net/StitchAuthDocRequest\";\nimport { StitchAuthRequest } from \"../../internal/net/StitchAuthRequest\";\nimport { StitchDocRequest } from \"../../internal/net/StitchDocRequest\";\nimport StitchClientError from \"../../StitchClientError\";\nimport { StitchClientErrorCode } from \"../../StitchClientErrorCode\";\nimport StitchError from \"../../StitchError\";\nimport StitchRequestError from \"../../StitchRequestError\";\nimport { StitchRequestErrorCode } from \"../../StitchRequestErrorCode\";\nimport StitchServiceError from \"../../StitchServiceError\";\nimport { StitchServiceErrorCode } from \"../../StitchServiceErrorCode\";\nimport StitchAuthResponseCredential from \"../providers/internal/StitchAuthResponseCredential\";\nimport AccessTokenRefresher from \"./AccessTokenRefresher\";\nimport AuthInfo from \"./AuthInfo\";\nimport JWT from \"./JWT\";\nimport ApiAuthInfo from \"./models/ApiAuthInfo\";\nimport ApiCoreUserProfile from \"./models/ApiCoreUserProfile\";\nimport { readFromStorage, writeToStorage } from \"./models/StoreAuthInfo\";\nvar OPTIONS = \"options\";\nvar DEVICE = \"device\";\n\nvar CoreStitchAuth = function () {\n  function CoreStitchAuth(requestClient, authRoutes, storage, useTokenRefresher) {\n    if (useTokenRefresher === void 0) {\n      useTokenRefresher = true;\n    }\n\n    this.requestClient = requestClient;\n    this.authRoutes = authRoutes;\n    this.storage = storage;\n    var info;\n\n    try {\n      info = readFromStorage(storage);\n    } catch (e) {\n      throw new StitchClientError(StitchClientErrorCode.CouldNotLoadPersistedAuthInfo);\n    }\n\n    if (info === undefined) {\n      this.authInfo = AuthInfo.empty();\n    } else {\n      this.authInfo = info;\n    }\n\n    this.prepUser();\n\n    if (useTokenRefresher) {\n      this.accessTokenRefresher = new AccessTokenRefresher(this);\n      this.accessTokenRefresher.run();\n    }\n  }\n\n  Object.defineProperty(CoreStitchAuth.prototype, \"isLoggedIn\", {\n    get: function get() {\n      return this.currentUser !== undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CoreStitchAuth.prototype, \"user\", {\n    get: function get() {\n      return this.currentUser;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CoreStitchAuth.prototype.doAuthenticatedRequest = function (stitchReq) {\n    var _this = this;\n\n    return this.requestClient.doRequest(this.prepareAuthRequest(stitchReq)).catch(function (err) {\n      return _this.handleAuthFailure(err, stitchReq);\n    });\n  };\n\n  CoreStitchAuth.prototype.doAuthenticatedRequestWithDecoder = function (stitchReq, decoder) {\n    return this.doAuthenticatedRequest(stitchReq).then(function (response) {\n      var obj = EJSON.parse(response.body, {\n        strict: false\n      });\n\n      if (decoder) {\n        return decoder.decode(obj);\n      }\n\n      return obj;\n    }).catch(function (err) {\n      throw wrapDecodingError(err);\n    });\n  };\n\n  CoreStitchAuth.prototype.openAuthenticatedEventStream = function (stitchReq, open) {\n    var _this = this;\n\n    if (open === void 0) {\n      open = true;\n    }\n\n    if (!this.isLoggedIn) {\n      throw new StitchClientError(StitchClientErrorCode.MustAuthenticateFirst);\n    }\n\n    var authToken;\n\n    if (stitchReq.useRefreshToken) {\n      authToken = this.authInfo.refreshToken;\n    } else {\n      authToken = this.authInfo.accessToken;\n    }\n\n    return this.requestClient.doStreamRequest(stitchReq.builder.withPath(stitchReq.path + \"&stitch_at=\" + authToken).build(), open, function () {\n      return _this.openAuthenticatedEventStream(stitchReq, false);\n    }).catch(function (err) {\n      return _this.handleAuthFailureForEventStream(err, stitchReq, open);\n    });\n  };\n\n  CoreStitchAuth.prototype.openAuthenticatedStreamWithDecoder = function (stitchReq, decoder) {\n    return this.openAuthenticatedEventStream(stitchReq).then(function (eventStream) {\n      return new Stream(eventStream, decoder);\n    });\n  };\n\n  CoreStitchAuth.prototype.refreshAccessToken = function () {\n    var _this = this;\n\n    var reqBuilder = new StitchAuthRequest.Builder().withRefreshToken().withPath(this.authRoutes.sessionRoute).withMethod(Method.POST);\n    return this.doAuthenticatedRequest(reqBuilder.build()).then(function (response) {\n      try {\n        var partialInfo = ApiAuthInfo.fromJSON(JSON.parse(response.body));\n        _this.authInfo = _this.authInfo.merge(partialInfo);\n      } catch (err) {\n        throw new StitchRequestError(err, StitchRequestErrorCode.DECODING_ERROR);\n      }\n\n      try {\n        writeToStorage(_this.authInfo, _this.storage);\n      } catch (err) {\n        throw new StitchClientError(StitchClientErrorCode.CouldNotPersistAuthInfo);\n      }\n    });\n  };\n\n  CoreStitchAuth.prototype.loginWithCredentialInternal = function (credential) {\n    if (credential instanceof StitchAuthResponseCredential) {\n      return this.processLogin(credential, credential.authInfo, credential.asLink);\n    }\n\n    if (!this.isLoggedIn) {\n      return this.doLogin(credential, false);\n    }\n\n    if (credential.providerCapabilities.reusesExistingSession) {\n      if (credential.providerType === this.currentUser.loggedInProviderType) {\n        return Promise.resolve(this.currentUser);\n      }\n    }\n\n    this.logoutInternal();\n    return this.doLogin(credential, false);\n  };\n\n  CoreStitchAuth.prototype.linkUserWithCredentialInternal = function (user, credential) {\n    if (this.currentUser !== undefined && user.id !== this.currentUser.id) {\n      return Promise.reject(new StitchClientError(StitchClientErrorCode.UserNoLongerValid));\n    }\n\n    return this.doLogin(credential, true);\n  };\n\n  CoreStitchAuth.prototype.logoutInternal = function () {\n    var _this = this;\n\n    if (!this.isLoggedIn) {\n      return Promise.resolve();\n    }\n\n    return this.doLogout().then(function () {\n      _this.clearAuth();\n    }).catch(function () {\n      _this.clearAuth();\n    });\n  };\n\n  Object.defineProperty(CoreStitchAuth.prototype, \"hasDeviceId\", {\n    get: function get() {\n      return this.authInfo.deviceId !== undefined && this.authInfo.deviceId !== \"\" && this.authInfo.deviceId !== \"000000000000000000000000\";\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CoreStitchAuth.prototype, \"deviceId\", {\n    get: function get() {\n      if (!this.hasDeviceId) {\n        return undefined;\n      }\n\n      return this.authInfo.deviceId;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CoreStitchAuth.prototype.prepareAuthRequest = function (stitchReq) {\n    if (!this.isLoggedIn) {\n      throw new StitchClientError(StitchClientErrorCode.MustAuthenticateFirst);\n    }\n\n    var newReq = stitchReq.builder;\n    var newHeaders = newReq.headers || {};\n\n    if (stitchReq.useRefreshToken) {\n      newHeaders[Headers.AUTHORIZATION] = Headers.getAuthorizationBearer(this.authInfo.refreshToken);\n    } else {\n      newHeaders[Headers.AUTHORIZATION] = Headers.getAuthorizationBearer(this.authInfo.accessToken);\n    }\n\n    newReq.withHeaders(newHeaders);\n    return newReq.build();\n  };\n\n  CoreStitchAuth.prototype.handleAuthFailureForEventStream = function (ex, req, open) {\n    var _this = this;\n\n    if (open === void 0) {\n      open = true;\n    }\n\n    if (!(ex instanceof StitchServiceError) || ex.errorCode !== StitchServiceErrorCode.InvalidSession) {\n      throw ex;\n    }\n\n    if (req.useRefreshToken || !req.shouldRefreshOnFailure) {\n      this.clearAuth();\n      throw ex;\n    }\n\n    return this.tryRefreshAccessToken(req.startedAt).then(function () {\n      return _this.openAuthenticatedEventStream(req.builder.withShouldRefreshOnFailure(false).build(), open);\n    });\n  };\n\n  CoreStitchAuth.prototype.handleAuthFailure = function (ex, req) {\n    var _this = this;\n\n    if (!(ex instanceof StitchServiceError) || ex.errorCode !== StitchServiceErrorCode.InvalidSession) {\n      throw ex;\n    }\n\n    if (req.useRefreshToken || !req.shouldRefreshOnFailure) {\n      this.clearAuth();\n      throw ex;\n    }\n\n    return this.tryRefreshAccessToken(req.startedAt).then(function () {\n      return _this.doAuthenticatedRequest(req.builder.withShouldRefreshOnFailure(false).build());\n    });\n  };\n\n  CoreStitchAuth.prototype.tryRefreshAccessToken = function (reqStartedAt) {\n    if (!this.isLoggedIn) {\n      throw new StitchClientError(StitchClientErrorCode.LoggedOutDuringRequest);\n    }\n\n    try {\n      var jwt = JWT.fromEncoded(this.authInfo.accessToken);\n\n      if (jwt.issuedAt >= reqStartedAt) {\n        return Promise.resolve();\n      }\n    } catch (e) {}\n\n    return this.refreshAccessToken();\n  };\n\n  CoreStitchAuth.prototype.prepUser = function () {\n    if (this.authInfo.userId !== undefined) {\n      this.currentUser = this.userFactory.makeUser(this.authInfo.userId, this.authInfo.loggedInProviderType, this.authInfo.loggedInProviderName, this.authInfo.userProfile);\n    }\n  };\n\n  CoreStitchAuth.prototype.attachAuthOptions = function (authBody) {\n    var options = {};\n    options[DEVICE] = this.deviceInfo;\n    authBody[OPTIONS] = options;\n  };\n\n  CoreStitchAuth.prototype.doLogin = function (credential, asLinkRequest) {\n    var _this = this;\n\n    return this.doLoginRequest(credential, asLinkRequest).then(function (response) {\n      return _this.processLoginResponse(credential, response, asLinkRequest);\n    }).then(function (user) {\n      _this.onAuthEvent();\n\n      return user;\n    });\n  };\n\n  CoreStitchAuth.prototype.doLoginRequest = function (credential, asLinkRequest) {\n    var reqBuilder = new StitchDocRequest.Builder();\n    reqBuilder.withMethod(Method.POST);\n\n    if (asLinkRequest) {\n      reqBuilder.withPath(this.authRoutes.getAuthProviderLinkRoute(credential.providerName));\n    } else {\n      reqBuilder.withPath(this.authRoutes.getAuthProviderLoginRoute(credential.providerName));\n    }\n\n    var material = credential.material;\n    this.attachAuthOptions(material);\n    reqBuilder.withDocument(material);\n\n    if (!asLinkRequest) {\n      return this.requestClient.doRequest(reqBuilder.build());\n    }\n\n    var linkRequest = new StitchAuthDocRequest(reqBuilder.build(), reqBuilder.document);\n    return this.doAuthenticatedRequest(linkRequest);\n  };\n\n  CoreStitchAuth.prototype.processLogin = function (credential, newAuthInfo, asLinkRequest) {\n    var _this = this;\n\n    var oldInfo = this.authInfo;\n    var oldUser = this.currentUser;\n    newAuthInfo = this.authInfo.merge(new AuthInfo(newAuthInfo.userId, newAuthInfo.deviceId, newAuthInfo.accessToken, newAuthInfo.refreshToken, credential.providerType, credential.providerName, undefined));\n    this.authInfo = newAuthInfo;\n    this.currentUser = this.userFactory.makeUser(this.authInfo.userId, credential.providerType, credential.providerName, undefined);\n    return this.doGetUserProfile().then(function (profile) {\n      newAuthInfo = newAuthInfo.merge(new AuthInfo(newAuthInfo.userId, newAuthInfo.deviceId, newAuthInfo.accessToken, newAuthInfo.refreshToken, credential.providerType, credential.providerName, profile));\n\n      try {\n        writeToStorage(newAuthInfo, _this.storage);\n      } catch (err) {\n        throw new StitchClientError(StitchClientErrorCode.CouldNotPersistAuthInfo);\n      }\n\n      _this.authInfo = newAuthInfo;\n      _this.currentUser = _this.userFactory.makeUser(_this.authInfo.userId, credential.providerType, credential.providerName, profile);\n      return _this.currentUser;\n    }).catch(function (err) {\n      if (asLinkRequest) {\n        _this.authInfo = oldInfo;\n        _this.currentUser = oldUser;\n      } else {\n        _this.clearAuth();\n      }\n\n      throw err;\n    });\n  };\n\n  CoreStitchAuth.prototype.processLoginResponse = function (credential, response, asLinkRequest) {\n    try {\n      if (!response) {\n        throw new StitchServiceError(\"the login response could not be processed for credential: \" + credential + \";\" + \"response was undefined\");\n      }\n\n      if (!response.body) {\n        throw new StitchServiceError(\"response with status code \" + response.statusCode + \" has empty body\");\n      }\n\n      return this.processLogin(credential, ApiAuthInfo.fromJSON(JSON.parse(response.body)), asLinkRequest);\n    } catch (err) {\n      throw new StitchRequestError(err, StitchRequestErrorCode.DECODING_ERROR);\n    }\n  };\n\n  CoreStitchAuth.prototype.doGetUserProfile = function () {\n    var reqBuilder = new StitchAuthRequest.Builder();\n    reqBuilder.withMethod(Method.GET).withPath(this.authRoutes.profileRoute);\n    return this.doAuthenticatedRequest(reqBuilder.build()).then(function (response) {\n      return ApiCoreUserProfile.fromJSON(JSON.parse(response.body));\n    }).catch(function (err) {\n      if (err instanceof StitchError) {\n        throw err;\n      } else {\n        throw new StitchRequestError(err, StitchRequestErrorCode.DECODING_ERROR);\n      }\n    });\n  };\n\n  CoreStitchAuth.prototype.doLogout = function () {\n    var reqBuilder = new StitchAuthRequest.Builder();\n    reqBuilder.withRefreshToken().withPath(this.authRoutes.sessionRoute).withMethod(Method.DELETE);\n    return this.doAuthenticatedRequest(reqBuilder.build()).then(function () {\n      return;\n    });\n  };\n\n  CoreStitchAuth.prototype.clearAuth = function () {\n    if (!this.isLoggedIn) {\n      return;\n    }\n\n    this.authInfo = this.authInfo.loggedOut();\n\n    try {\n      writeToStorage(this.authInfo, this.storage);\n    } catch (e) {\n      throw new StitchClientError(StitchClientErrorCode.CouldNotPersistAuthInfo);\n    }\n\n    this.currentUser = undefined;\n    this.onAuthEvent();\n  };\n\n  CoreStitchAuth.prototype.close = function () {\n    if (this.accessTokenRefresher) {\n      this.accessTokenRefresher.stop();\n    }\n  };\n\n  return CoreStitchAuth;\n}();\n\nexport default CoreStitchAuth;","map":{"version":3,"sources":["../../../../src/auth/internal/CoreStitchAuth.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as EJSON from \"mongodb-stitch-extjson\";\nimport { wrapDecodingError } from \"../../internal/common/StitchErrorUtils\";\nimport Headers from \"../../internal/net/Headers\";\nimport Method from \"../../internal/net/Method\";\nimport Stream from \"../../internal/net/Stream\";\nimport { StitchAuthDocRequest } from \"../../internal/net/StitchAuthDocRequest\";\nimport { StitchAuthRequest } from \"../../internal/net/StitchAuthRequest\";\nimport { StitchDocRequest } from \"../../internal/net/StitchDocRequest\";\nimport StitchClientError from \"../../StitchClientError\";\nimport { StitchClientErrorCode } from \"../../StitchClientErrorCode\";\nimport StitchError from \"../../StitchError\";\nimport StitchRequestError from \"../../StitchRequestError\";\nimport { StitchRequestErrorCode } from \"../../StitchRequestErrorCode\";\nimport StitchServiceError from \"../../StitchServiceError\";\nimport { StitchServiceErrorCode } from \"../../StitchServiceErrorCode\";\nimport StitchAuthResponseCredential from \"../providers/internal/StitchAuthResponseCredential\";\nimport AccessTokenRefresher from \"./AccessTokenRefresher\";\nimport AuthInfo from \"./AuthInfo\";\nimport JWT from \"./JWT\";\nimport ApiAuthInfo from \"./models/ApiAuthInfo\";\nimport ApiCoreUserProfile from \"./models/ApiCoreUserProfile\";\nimport { readFromStorage, writeToStorage } from \"./models/StoreAuthInfo\";\nvar OPTIONS = \"options\";\nvar DEVICE = \"device\";\nvar CoreStitchAuth = (function () {\n    function CoreStitchAuth(requestClient, authRoutes, storage, useTokenRefresher) {\n        if (useTokenRefresher === void 0) { useTokenRefresher = true; }\n        this.requestClient = requestClient;\n        this.authRoutes = authRoutes;\n        this.storage = storage;\n        var info;\n        try {\n            info = readFromStorage(storage);\n        }\n        catch (e) {\n            throw new StitchClientError(StitchClientErrorCode.CouldNotLoadPersistedAuthInfo);\n        }\n        if (info === undefined) {\n            this.authInfo = AuthInfo.empty();\n        }\n        else {\n            this.authInfo = info;\n        }\n        this.prepUser();\n        if (useTokenRefresher) {\n            this.accessTokenRefresher = new AccessTokenRefresher(this);\n            this.accessTokenRefresher.run();\n        }\n    }\n    Object.defineProperty(CoreStitchAuth.prototype, \"isLoggedIn\", {\n        get: function () {\n            return this.currentUser !== undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CoreStitchAuth.prototype, \"user\", {\n        get: function () {\n            return this.currentUser;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CoreStitchAuth.prototype.doAuthenticatedRequest = function (stitchReq) {\n        var _this = this;\n        return this.requestClient\n            .doRequest(this.prepareAuthRequest(stitchReq))\n            .catch(function (err) {\n            return _this.handleAuthFailure(err, stitchReq);\n        });\n    };\n    CoreStitchAuth.prototype.doAuthenticatedRequestWithDecoder = function (stitchReq, decoder) {\n        return this.doAuthenticatedRequest(stitchReq)\n            .then(function (response) {\n            var obj = EJSON.parse(response.body, { strict: false });\n            if (decoder) {\n                return decoder.decode(obj);\n            }\n            return obj;\n        })\n            .catch(function (err) {\n            throw wrapDecodingError(err);\n        });\n    };\n    CoreStitchAuth.prototype.openAuthenticatedEventStream = function (stitchReq, open) {\n        var _this = this;\n        if (open === void 0) { open = true; }\n        if (!this.isLoggedIn) {\n            throw new StitchClientError(StitchClientErrorCode.MustAuthenticateFirst);\n        }\n        var authToken;\n        if (stitchReq.useRefreshToken) {\n            authToken = this.authInfo.refreshToken;\n        }\n        else {\n            authToken = this.authInfo.accessToken;\n        }\n        return this.requestClient.doStreamRequest(stitchReq.builder\n            .withPath(stitchReq.path + \"&stitch_at=\" + authToken)\n            .build(), open, function () { return _this.openAuthenticatedEventStream(stitchReq, false); })\n            .catch(function (err) {\n            return _this.handleAuthFailureForEventStream(err, stitchReq, open);\n        });\n    };\n    CoreStitchAuth.prototype.openAuthenticatedStreamWithDecoder = function (stitchReq, decoder) {\n        return this.openAuthenticatedEventStream(stitchReq)\n            .then(function (eventStream) {\n            return new Stream(eventStream, decoder);\n        });\n    };\n    CoreStitchAuth.prototype.refreshAccessToken = function () {\n        var _this = this;\n        var reqBuilder = new StitchAuthRequest.Builder()\n            .withRefreshToken()\n            .withPath(this.authRoutes.sessionRoute)\n            .withMethod(Method.POST);\n        return this.doAuthenticatedRequest(reqBuilder.build()).then(function (response) {\n            try {\n                var partialInfo = ApiAuthInfo.fromJSON(JSON.parse(response.body));\n                _this.authInfo = _this.authInfo.merge(partialInfo);\n            }\n            catch (err) {\n                throw new StitchRequestError(err, StitchRequestErrorCode.DECODING_ERROR);\n            }\n            try {\n                writeToStorage(_this.authInfo, _this.storage);\n            }\n            catch (err) {\n                throw new StitchClientError(StitchClientErrorCode.CouldNotPersistAuthInfo);\n            }\n        });\n    };\n    CoreStitchAuth.prototype.loginWithCredentialInternal = function (credential) {\n        if (credential instanceof StitchAuthResponseCredential) {\n            return this.processLogin(credential, credential.authInfo, credential.asLink);\n        }\n        if (!this.isLoggedIn) {\n            return this.doLogin(credential, false);\n        }\n        if (credential.providerCapabilities.reusesExistingSession) {\n            if (credential.providerType === this.currentUser.loggedInProviderType) {\n                return Promise.resolve(this.currentUser);\n            }\n        }\n        this.logoutInternal();\n        return this.doLogin(credential, false);\n    };\n    CoreStitchAuth.prototype.linkUserWithCredentialInternal = function (user, credential) {\n        if (this.currentUser !== undefined && user.id !== this.currentUser.id) {\n            return Promise.reject(new StitchClientError(StitchClientErrorCode.UserNoLongerValid));\n        }\n        return this.doLogin(credential, true);\n    };\n    CoreStitchAuth.prototype.logoutInternal = function () {\n        var _this = this;\n        if (!this.isLoggedIn) {\n            return Promise.resolve();\n        }\n        return this.doLogout()\n            .then(function () {\n            _this.clearAuth();\n        })\n            .catch(function () {\n            _this.clearAuth();\n        });\n    };\n    Object.defineProperty(CoreStitchAuth.prototype, \"hasDeviceId\", {\n        get: function () {\n            return (this.authInfo.deviceId !== undefined &&\n                this.authInfo.deviceId !== \"\" &&\n                this.authInfo.deviceId !== \"000000000000000000000000\");\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CoreStitchAuth.prototype, \"deviceId\", {\n        get: function () {\n            if (!this.hasDeviceId) {\n                return undefined;\n            }\n            return this.authInfo.deviceId;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CoreStitchAuth.prototype.prepareAuthRequest = function (stitchReq) {\n        if (!this.isLoggedIn) {\n            throw new StitchClientError(StitchClientErrorCode.MustAuthenticateFirst);\n        }\n        var newReq = stitchReq.builder;\n        var newHeaders = newReq.headers || {};\n        if (stitchReq.useRefreshToken) {\n            newHeaders[Headers.AUTHORIZATION] = Headers.getAuthorizationBearer(this.authInfo.refreshToken);\n        }\n        else {\n            newHeaders[Headers.AUTHORIZATION] = Headers.getAuthorizationBearer(this.authInfo.accessToken);\n        }\n        newReq.withHeaders(newHeaders);\n        return newReq.build();\n    };\n    CoreStitchAuth.prototype.handleAuthFailureForEventStream = function (ex, req, open) {\n        var _this = this;\n        if (open === void 0) { open = true; }\n        if (!(ex instanceof StitchServiceError) ||\n            ex.errorCode !== StitchServiceErrorCode.InvalidSession) {\n            throw ex;\n        }\n        if (req.useRefreshToken || !req.shouldRefreshOnFailure) {\n            this.clearAuth();\n            throw ex;\n        }\n        return this.tryRefreshAccessToken(req.startedAt).then(function () {\n            return _this.openAuthenticatedEventStream(req.builder.withShouldRefreshOnFailure(false).build(), open);\n        });\n    };\n    CoreStitchAuth.prototype.handleAuthFailure = function (ex, req) {\n        var _this = this;\n        if (!(ex instanceof StitchServiceError) ||\n            ex.errorCode !== StitchServiceErrorCode.InvalidSession) {\n            throw ex;\n        }\n        if (req.useRefreshToken || !req.shouldRefreshOnFailure) {\n            this.clearAuth();\n            throw ex;\n        }\n        return this.tryRefreshAccessToken(req.startedAt).then(function () {\n            return _this.doAuthenticatedRequest(req.builder.withShouldRefreshOnFailure(false).build());\n        });\n    };\n    CoreStitchAuth.prototype.tryRefreshAccessToken = function (reqStartedAt) {\n        if (!this.isLoggedIn) {\n            throw new StitchClientError(StitchClientErrorCode.LoggedOutDuringRequest);\n        }\n        try {\n            var jwt = JWT.fromEncoded(this.authInfo.accessToken);\n            if (jwt.issuedAt >= reqStartedAt) {\n                return Promise.resolve();\n            }\n        }\n        catch (e) {\n        }\n        return this.refreshAccessToken();\n    };\n    CoreStitchAuth.prototype.prepUser = function () {\n        if (this.authInfo.userId !== undefined) {\n            this.currentUser = this.userFactory.makeUser(this.authInfo.userId, this.authInfo.loggedInProviderType, this.authInfo.loggedInProviderName, this.authInfo.userProfile);\n        }\n    };\n    CoreStitchAuth.prototype.attachAuthOptions = function (authBody) {\n        var options = {};\n        options[DEVICE] = this.deviceInfo;\n        authBody[OPTIONS] = options;\n    };\n    CoreStitchAuth.prototype.doLogin = function (credential, asLinkRequest) {\n        var _this = this;\n        return this.doLoginRequest(credential, asLinkRequest)\n            .then(function (response) { return _this.processLoginResponse(credential, response, asLinkRequest); })\n            .then(function (user) {\n            _this.onAuthEvent();\n            return user;\n        });\n    };\n    CoreStitchAuth.prototype.doLoginRequest = function (credential, asLinkRequest) {\n        var reqBuilder = new StitchDocRequest.Builder();\n        reqBuilder.withMethod(Method.POST);\n        if (asLinkRequest) {\n            reqBuilder.withPath(this.authRoutes.getAuthProviderLinkRoute(credential.providerName));\n        }\n        else {\n            reqBuilder.withPath(this.authRoutes.getAuthProviderLoginRoute(credential.providerName));\n        }\n        var material = credential.material;\n        this.attachAuthOptions(material);\n        reqBuilder.withDocument(material);\n        if (!asLinkRequest) {\n            return this.requestClient.doRequest(reqBuilder.build());\n        }\n        var linkRequest = new StitchAuthDocRequest(reqBuilder.build(), reqBuilder.document);\n        return this.doAuthenticatedRequest(linkRequest);\n    };\n    CoreStitchAuth.prototype.processLogin = function (credential, newAuthInfo, asLinkRequest) {\n        var _this = this;\n        var oldInfo = this.authInfo;\n        var oldUser = this.currentUser;\n        newAuthInfo = this.authInfo.merge(new AuthInfo(newAuthInfo.userId, newAuthInfo.deviceId, newAuthInfo.accessToken, newAuthInfo.refreshToken, credential.providerType, credential.providerName, undefined));\n        this.authInfo = newAuthInfo;\n        this.currentUser = this.userFactory.makeUser(this.authInfo.userId, credential.providerType, credential.providerName, undefined);\n        return this.doGetUserProfile()\n            .then(function (profile) {\n            newAuthInfo = newAuthInfo.merge(new AuthInfo(newAuthInfo.userId, newAuthInfo.deviceId, newAuthInfo.accessToken, newAuthInfo.refreshToken, credential.providerType, credential.providerName, profile));\n            try {\n                writeToStorage(newAuthInfo, _this.storage);\n            }\n            catch (err) {\n                throw new StitchClientError(StitchClientErrorCode.CouldNotPersistAuthInfo);\n            }\n            _this.authInfo = newAuthInfo;\n            _this.currentUser = _this.userFactory.makeUser(_this.authInfo.userId, credential.providerType, credential.providerName, profile);\n            return _this.currentUser;\n        })\n            .catch(function (err) {\n            if (asLinkRequest) {\n                _this.authInfo = oldInfo;\n                _this.currentUser = oldUser;\n            }\n            else {\n                _this.clearAuth();\n            }\n            throw err;\n        });\n    };\n    CoreStitchAuth.prototype.processLoginResponse = function (credential, response, asLinkRequest) {\n        try {\n            if (!response) {\n                throw new StitchServiceError(\"the login response could not be processed for credential: \" + credential + \";\" +\n                    \"response was undefined\");\n            }\n            if (!response.body) {\n                throw new StitchServiceError(\"response with status code \" + response.statusCode + \" has empty body\");\n            }\n            return this.processLogin(credential, ApiAuthInfo.fromJSON(JSON.parse(response.body)), asLinkRequest);\n        }\n        catch (err) {\n            throw new StitchRequestError(err, StitchRequestErrorCode.DECODING_ERROR);\n        }\n    };\n    CoreStitchAuth.prototype.doGetUserProfile = function () {\n        var reqBuilder = new StitchAuthRequest.Builder();\n        reqBuilder.withMethod(Method.GET).withPath(this.authRoutes.profileRoute);\n        return this.doAuthenticatedRequest(reqBuilder.build())\n            .then(function (response) { return ApiCoreUserProfile.fromJSON(JSON.parse(response.body)); })\n            .catch(function (err) {\n            if (err instanceof StitchError) {\n                throw err;\n            }\n            else {\n                throw new StitchRequestError(err, StitchRequestErrorCode.DECODING_ERROR);\n            }\n        });\n    };\n    CoreStitchAuth.prototype.doLogout = function () {\n        var reqBuilder = new StitchAuthRequest.Builder();\n        reqBuilder\n            .withRefreshToken()\n            .withPath(this.authRoutes.sessionRoute)\n            .withMethod(Method.DELETE);\n        return this.doAuthenticatedRequest(reqBuilder.build()).then(function () {\n            return;\n        });\n    };\n    CoreStitchAuth.prototype.clearAuth = function () {\n        if (!this.isLoggedIn) {\n            return;\n        }\n        this.authInfo = this.authInfo.loggedOut();\n        try {\n            writeToStorage(this.authInfo, this.storage);\n        }\n        catch (e) {\n            throw new StitchClientError(StitchClientErrorCode.CouldNotPersistAuthInfo);\n        }\n        this.currentUser = undefined;\n        this.onAuthEvent();\n    };\n    CoreStitchAuth.prototype.close = function () {\n        if (this.accessTokenRefresher) {\n            this.accessTokenRefresher.stop();\n        }\n    };\n    return CoreStitchAuth;\n}());\nexport default CoreStitchAuth;\n//# sourceMappingURL=CoreStitchAuth.js.map"]},"metadata":{},"sourceType":"module"}